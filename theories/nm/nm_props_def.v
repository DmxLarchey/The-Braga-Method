(**************************************************************)
(*   Copyright Dominique Larchey-Wendling    [*]              *)
(*             Jean-François Monin           [+]              *)
(*                                                            *)
(*            [*] Affiliation LORIA -- CNRS                   *)
(*            [+] Affiliation VERIMAG - Univ. Grenoble-Alpes  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*         CeCILL v2 FREE SOFTWARE LICENSE AGREEMENT          *)
(**************************************************************)

Require Import Arith Lia Utf8. (* → λ ∀ ∃ ↔ ∧ ∨ ≤ *)

Require Import nm_graph_def.

Set Implicit Arguments.

Inductive normal : Ω → Prop :=
  | in_normal_0 : normal α
  | in_normal_1 y z : normal y → normal z → normal (ω α y z).

Hint Constructors normal : core.

(* Notation ℕ := normal. *)

(** equiv is the congruence generated by ω (ω a b c) y z ~e ω a (ω b y z) (ω c y z) *)

Reserved Notation "x '~Ω' y" (at level 70, no associativity).

Inductive equiv : Ω -> Ω -> Prop :=
  | in_eq_0 u v w y z : ω (ω u v w) y z ~Ω ω u (ω v y z) (ω w y z)
  | in_eq_1 x x' y y' z z' : x ~Ω x' -> y ~Ω y' -> z ~Ω z'-> ω x y z ~Ω ω x' y' z'
  | in_eq_2 : α ~Ω α
  | in_eq_3 x y z : x ~Ω y -> y ~Ω z -> x ~Ω z
where "x ~Ω y" := (equiv x y).

Hint Constructors equiv : core.

Notation equiv_trans := in_eq_3.

Fact equiv_refl e : e ~Ω e.
Proof. induction e; auto. Qed.

Hint Resolve equiv_refl : core.

Notation "⟦ x , y , z ⟧" := (x*(1+y+z)) (at level 1, format "⟦ x , y , z ⟧").

(* The next properties are sufficient for the measure *)

(* → λ ∀ ∃ ↔ ∧ ∨ ≤ *)

Local Fact c_mono x x' y y' z z' : x ≤ x' → y ≤ y' → z ≤ z' → ⟦x,y,z⟧ ≤ ⟦x',y',z'⟧.
Proof. intros; simpl; apply mult_le_compat; lia. Qed.

Local Fact c_smono_1 x x' y z : x < x' → ⟦x,y,z⟧ < ⟦x',y,z⟧.
Proof. intro; simpl; apply mult_lt_compat_r; lia. Qed.

Local Fact c_smono_2 x y y' z : 0 < x → y < y' → ⟦x,y,z⟧ < ⟦x,y',z⟧.
Proof. intros; simpl; apply mult_lt_compat_l; lia. Qed.

Local Fact c_smono_3 x y z z' : 0 < x → z < z' → ⟦x,y,z⟧ < ⟦x,y,z'⟧.
Proof. intros; simpl; apply mult_lt_compat_l; lia. Qed.

Local Fact c_inc_1 x y z : x ≤ ⟦x,y,z⟧.
Proof. rewrite <- Nat.mul_1_r at 1; apply mult_le_compat; lia. Qed.

Local Fact c_sinc_1 x y z : 0 < x → 0 < y + z → x < ⟦x,y,z⟧.
Proof. intros ? ?; rewrite <- Nat.mul_1_r at 1; apply mult_lt_compat_l; lia. Qed.

Local Fact c_sinc_2 x y z : 0 < x → y < ⟦x,y,z⟧.
Proof. intros ?; unfold lt; rewrite <- Nat.mul_1_l at 1; apply mult_le_compat; lia. Qed.

Local Fact c_sinc_3 x y z : 0 < x → z < ⟦x,y,z⟧. 
Proof. intros ?; unfold lt; rewrite <- Nat.mul_1_l at 1; apply mult_le_compat; lia. Qed.

Local Fact c_special u v w y z : 0 < u → 0 < y + z → ⟦u,⟦v,y,z⟧,⟦w,y,z⟧⟧ < ⟦⟦u,v,w⟧,y,z⟧.
Proof.
  intros ? ?.
  rewrite <- mult_assoc.
  apply mult_lt_compat_l; auto.
  simpl.
  generalize (S (y + z)); intros n.
  rewrite mult_plus_distr_r; lia.
Qed.

Reserved Notation "⟪ e ⟫" (at level 1).

(** This is the decreasing measure *)

Fixpoint ce_size e :=
  match e with
    | α => 1
    | ω x y z => ⟦⟪x⟫,⟪y⟫,⟪z⟫⟧
  end
where "⟪ e ⟫" := (ce_size e).

(* Some elementary properties of the measure *)

(* → λ ∀ ∃ ↔ ∧ ∨ ≤ ¬ *)

Fact ce_size_mono x x' y y' z z' : 
   ⟪x⟫ ≤ ⟪x'⟫ → ⟪y⟫ ≤ ⟪y'⟫ → ⟪z⟫ ≤ ⟪z'⟫ → ⟪ω x y z⟫ ≤ ⟪ω x' y' z'⟫.
Proof. apply c_mono. Qed.

Fact ce_size_smono_1 x x' y z : ⟪x⟫ < ⟪x'⟫ → ⟪ω x y z⟫ < ⟪ω x' y z⟫.
Proof. apply c_smono_1. Qed.

Fact ce_size_ge_1 e : 1 ≤ ⟪e⟫.
Proof.
  induction e as [ | x Hx y _  z _ ].
  + simpl; auto.
  + apply le_trans with (1 := Hx), c_inc_1.
Qed.

Hint Resolve ce_size_ge_1 : core.

Fact ce_size_smono_2 x y y' z : ⟪y⟫ < ⟪y'⟫ → ⟪ω x y z⟫ < ⟪ω x y' z⟫.
Proof. simpl; apply c_smono_2, ce_size_ge_1. Qed.

Fact ce_size_smono_3 x y z z' : ⟪z⟫ < ⟪z'⟫ → ⟪ω x y z⟫ < ⟪ω x y z'⟫.
Proof. simpl; apply c_smono_3, ce_size_ge_1. Qed.

Fact ce_size_sub_1 x y z : ⟪x⟫ < ⟪ω x y z⟫.
Proof. simpl; apply c_sinc_1; auto; generalize (ce_size_ge_1 y); lia. Qed.

Fact ce_size_sub_2 x y z : ⟪y⟫ < ⟪ω x y z⟫.
Proof. simpl; apply c_sinc_2; auto. Qed.

Fact ce_size_sub_3 x y z : ⟪z⟫ < ⟪ω x y z⟫.
Proof. simpl; apply c_sinc_3; auto. Qed.

(* The special properties that makes it a suitable measure for induction *)

Fact ce_size_special a b c y z : 
       ⟪ω a (ω b y z) (ω c y z)⟫ < ⟪ω (ω a b c) y z⟫.
Proof. simpl; apply c_special; auto; generalize (ce_size_ge_1 y); lia. Qed.

Hint Resolve ce_size_smono_1 ce_size_smono_2 ce_size_smono_3 : core.

Fact equiv_ce_size x y : x ~Ω y → x = y ∨ ⟪y⟫ < ⟪x⟫.
Proof.
  induction 1 as [ | x x' y y' z z' _ IH1 _ IH2 _ IH3 | | x y z _ IH1 _ IH2 ]; auto.
  + right; apply ce_size_special.
  + destruct IH1 as [ [] | H1 ]; 
    destruct IH2 as [ [] | H2 ]; 
    destruct IH3 as [ [] | H3 ]; auto; right; auto.
    1,2: apply lt_trans with ⟪ω x y z'⟫; auto.
    1,2: apply lt_trans with ⟪ω x' y z⟫; auto.
    apply lt_trans with ⟪ω x' y' z⟫; auto.
  + destruct IH1 as [ -> | H1 ]; auto.
    destruct IH2 as [ -> | H2 ]; auto.
    right; now apply lt_trans with (1 := H2).
Qed.

Fact equiv_not_sym a b c y z : ¬ ω a (ω b y z) (ω c y z) ~Ω ω (ω a b c) y z.
Proof.
  intros H.
  apply equiv_ce_size in H.
  destruct H as [ H | H ]; 
    [ apply f_equal with (f := ce_size) in H | ];
    generalize (ce_size_special a b c y z); lia.
Qed.
